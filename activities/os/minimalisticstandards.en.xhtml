<?xml version="1.0" encoding="UTF-8" ?>

<html>
  <head>
    <title>Minimalistic Data Format – Open Standards – FSFE</title>
  </head>
  <body id="article">
    <p id="category">
      <a href="/activities/os/os.html">Open Standards</a>
    </p>
    <h1>The minimal principle, 
	because being an open standard is not enough.</h1>

    <p>A tool is useless without a piece of wood to work on. 
    What are the workpieces we shape with our computers?
    Data, information, knowledge, opinions, art – in short: Content. It is being 
    created, processed and transmitted, often in an electronic format. 
    The number of people owning devices connecting to the internet is constantly
    rising. And they use it to evolve their ways of working together.
    </p>

    <p>So content is send from one user to another and back. For this it needs to take
    on some form: The data-format, which defines how content and its wrapping is handled, 
    what is allowed and how each bit looks within a file or stream. Whoever wants 
    to participate in the exchange must use a software application that understands the
    data-format in question. Otherwise the content would appear like an unknown 
    foreign language to your computer. If a data-format does not allow to include pictures, 
    then there is no way to save pictures with it.
    The choice of data-format dictates how long I may access the content 
    and what I am able do with it.
    </p>

    <p>When saving a file in a particular data-format, 
    a single user probably will not feel any effect of her decision. 
    When an IT-department or a public administration decides for a data-format 
    the impact is far greater: It will dominate their choice of software 
    for several years, even decades. The more an organisation saves precious 
    writings, recordings or pictures electronically, the more important 
    it becomes to secure continued access to the documents.
    Consciously or indirectly these decisions lead to the funding of the initial development
    and maintenance of data-formats.
    Many software producers intentionally try to influence users to 
    use one of the data-formats they control. For example for technical schematics of 
    vehicles, buildings or machinery. Later the producer of the CAD application in question
    basically can hold the data for ransom. From the vendor’s point of view 
    this is a strong position for the next upcoming priceing negotiation.
    Even some countries managed to maneuvers themself into the losing end of this situation.
    </p>

    <p>Therefore a good data-format can only be an <a
      href="/activities/os/def.html">Open Standard</a>.
    This requirement however is not enough. The data-format needs to solve a problem
    adequately: It needs to be a good fit from a functional as well 
    as a technical point of view. In order to judge this, there are a number
    of aspects. The <a
      href="http://jendryschik.de/wsdev/trans/designguide/">Essay by Bert
      Bos</a> explains the design principles of the W3C - the organisation which develops the formats 
    of the world wide web. He mentions efficiency, maintainability, accessibility, 
    extensibility, learnability, simplicity, durability and a few more.</p>

    <p>The two central questions here are:</p><ul>
      <li>How well does the data-format solve the problem? And:</li>
      <li>Is it the most simple data-format available or is there even a simpler one?</li></ul>


    <p>The first question is self-explanatory: Whoever wants to save, transmit and search within 
    a text would not want a format for pixel based images – though it is inevitable
    using such a format during the first step of scanning papers or 
    incoming facsimiles.</p>

    <p>The second question is much more interesting: Is the format as simple as possible and as 
    complicated as necessary? It is very hard to design or choose a data-format 
    which follows this principle of minimalism.</p>

    <p>First there is the bad influence of a pattern called <a
      href="http://sourcemaking.com/antipatterns/design-by-committee">“Design
      by Committee”</a>, which stands for the 
      participation of several decision makers when deciding a technical question. 
      Frequently many people are involved on the development of a standard. 
      Decisions about what software product 
      to use within an organisation – especially in public ones – are also often made by large committees. 
      Then it easily happens that too many cooks spoil the broth and add more than 
      actually necessary. The W3C at least <a
      href="http://www.w3.org/People/Bos/DesignGuide/committee.html">
      is aware of this pattern, says Bos</a>. Many groups are not.</p>


    <p>A second problem is the commong use of checklists when evaluating software solutions. 
    Typically
    is goes like this: Every stakeholder can add something to the list. The given 
    wishes are often specific solution ideas and get condensed into the checklist
    for the procurement departement. The software product promising most items wins.
    Most of the time this means buying a single data-format which has 
    many rarely used and unneeded features. It would be better to add wishes 
    in a problem orientated manner. The evaluation process should reward higher grades 
    for solutions which consists out of a number of simple, easily extensible 
    and orthogonal data-formats which can be combined for the more complex needs.</p>

    <p>But software vendors know their customers. The more features on a checklist are ticked 
    the more precious a software appears. That is because it seems to – at first glance – 
    serve many needs. Except for the need for simple elegance. And that is how software 
    and the data-format will look like: Bloated with many features, to reflect as many
    specific solution ideas as possible. This gives the software producer another edge:
    Any competitor will have a harder time to work will all features of the format 
    or to offer a superior solution or a part of the problem space. 
    The customer is forced to buy all or nothing. Why bother with another data-format 
    when there is one that can do everything?</p>

    <p>Every additional feature or guideline complicates the description of the data-format 
    exponentially. The disadvantages are enormous. The developers of a software 
    that needs to handle a data-format need to understand the description in total. This includes 
    the whole text and then all possible combinations of the contained elements. 
    Having to read and understand less means the resulting software implementation will 
    be simpler and more secure. This leads to more software which can handle the data-format 
    on a high level. What follows is more competition, 
    choice and therefore more users for this format.</p>

    <p>The more involved a data-format is, the greater the chance it has
    rarely needed features. So the format and the implementation are comparable to a 
    huge and angled mansion. Some rooms are very popular, other places are never visited
    by people. Of course such a house is hard to secure. 
    Burglars could push open a lonely forgotten window to 
    the basement or hide tools in a comb-webbed corner during an official visit to
    the premises.
    </p>

    <p>Experts see complexity as the biggest threat to software security. This is why
    many of them are critical or even hostile towards standards. 
    <a class="fn" id="ref-complexity" href="#fn-complexity">1</a></p>

    <p>To get an understanding of the risks let us take a look at how a computer deals
    with written characters. A commonly used standard is Latin-9 (ISO/IEC 8859-15).
    It enables a computer to save texts in more than 20 languages - mostly western European ones.
    For a single electronic character there are 256 different possibilities.
    A new standard called Unicode (ISO 10646) is supposed to encode all languages of the world. 
    Therefor it comes with more than a million possibilities.
    To make things worse, a single character could be encoded in several different ways.
    For example in "UTF-8" or "UCS-2". On one side Unicode is a blessing:
    Once implemented correctly an application is prepared to handle hundreds of languages. On 
    the other hand a programmer cannot fully calculate in her head all effects
    a character might have when looking at the source code of a software.
    With the 256 cases of Latin-9 she could. With Unicode this overview gets lost. 
    A clever attacker might find combinations the developer did not think of. This 
    happens on a regular basis. Here are two examples: 
     1. <a href="http://en.wikipedia.org/wiki/IDN_homograph_attack">the IDN homograph attack</a> 
     plays tricks on the users with similar looking Internet addresses. 
     Cyrillic from the Unicode-Fonts is well suitable for this. 
     2. The developers of a well known webserver fell prey to 
     <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CAN-2000-0884"
     >the possibilities of Unicode in URLs</a>.</p>

    <p>Unsurprisingly there are more applications out there that can handle Latin-9 
    correctly than Unicode. It is the same problem with every "fat" data-format: 
    There are applications that do not understand the more exotic features. 
    If not just because it has become impossible to test the myriad of features.
    The software will advertise that it can read data-format 
    data-format “X” but whether this works in practice is questionable.</p>

    <p>Some data-formats create this problem on purpose: 
    There come in different revisions. To be sure that software packages are compatible,
    you have to give the precise version of the used data-format.
    For example there are three variants (1.0, 1.1 and 1.2) of the Open Document Format (ODF). 
    It is likely the complexity grows with the number. Certainly there are many 
    cases where using the features of version 1.0 would be completely okay.
    But the default probably is to save files in the newest version the software supports. 
    For PDF this problem is even more significant. Some <a
      href="http://pdfreaders.org/os.en.html">versions or parts of PDFs</a> do not even 
    make an open standard.</p>

    <p>We teach school children who learn about computers to make distinction between
    data and instructions. While data is merely processed, the instructions command
    the computer. Imagine the writing of a piece of paper: Jump off the bridge! 
    I can read the data, process it by writing it down or handing to someone else
    without problems. But if I consider it to be instructions, I may easily get hurt
    following them. It is the same for computers.
    Data-formats like ODF, DOC and PDF beside data may also contain instructions for automatic 
    execution (“Macros”) or interactive elements (Javascript). This turns a regular file into 
    a potential application controling your computer. Naturally attackers try to take 
    advantage of this. Like with the 
    <a href="http://www.cert.org/tech_tips/Melissa_FAQ.html"
	    >Melissa Macro Virus from 1999</a>.</p>

    <p>Most texts flowing around only need a small fraction of that what common 
    data-formats have to offer in terms of formatting, mark-up or layout. 
    Since decades a simple file 
    composed of Latin-9 characters can be edited on every computer by means of 
    a simple text editor or any word processor. 
    A small subset of HTML 2 could cater for advanced needs like
    headlines, bullet-lists and hyperlinks. Alternatively any 
    <a href="http://en.wikipedia.org/wiki/Creole_%28markup%29"
	    >simple textbased markup language</a> 
    like used by Wikis would do.
    The wikipedia pages and weblogs of the world proof
    that lot of content can be expressed with these simple means.</p>

    <p>Everyone –  except a vendor of proprietary software – profits from different
    software products competing which each other, while being secure and interopable.
    The minimal principle for data-formats promotes all this. 
    It just has one rule: Remove everything that is not absolutely necessary.
    Aim for your design to be 
    <a href="http://www.paulgraham.com/taste.html">simple and elegant</a>. 
    A good solution resembles as set of building blocks where 
    an infinite number of buildings can be made, just by combining 
    a few types of elements.</p>

    <p>Even though there may be good reasons to choose a data-format which covers several 
    requirements we should ask ourselves each time: “Can this be done simpler?”</p>

    <h2 id="fn">Footnotes</h2>
    <ol> 
      <li id="fn-complexity">"Complexity is the main enemy of security",
    Ferguson, Niels, and Schneier, Bruce - Practical Cryptography, Wiley, 2003,
    ISBN 0-471-22357-3. p146 "9.4.1 Simplicity", pp365- "23 Standards"
    <a href="http://www.schneier.com/book-practical.html">http://www.schneier.com/book-practical.html</a>  [<a href="#ref-complexity">&#8626;</a>]</li>
  </ol>

  </body>

  <timestamp>$Date$ $Author$</timestamp>
<tags>
<tag>open-standards</tag>
</tags>
<legal type="cc-license">
 <license>https://creativecommons.org/licenses/by-sa/3.0/</license><notice>Neben der Standardlizenz der Webseite steht dieser Artikel unter der Creative Commons Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</notice>
</legal>
<author id="reiter" />
<!-- <date>
  <original content="2012-03-23" />
</date> -->
<translator>Philipp Kammerer</translator>
</html>
